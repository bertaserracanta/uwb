/*
 * crc.h
 *
 * Code generated by universal_crc by Danjel McGougan
 *
 * CRC parameters used:
 *   bits:       32
 *   poly:       0x84c11db7
 *   init:       0xa54242a5
 *   xor:        0x42a5a542
 *   reverse:    false
 *   non-direct: false
 *
 * CRC of the string "123456789" is 0x2eacc4dd
 */

//universal_crc.exe -b 32 -p 0x84c11db7 -i 0xA54242A5 -x 0x42A5A542 -a tabw > crc32.c

#ifndef CRC_H_
#define CRC_H_

#include <stddef.h>
#include <stdint.h>

#define ARCH_LITTLE_ENDIAN 1

uint32_t crc_calc(const uint8_t *data, size_t len);

extern const uint32_t crc_table[256];

static inline uint32_t crc_init(void)
{
	return 0xa54242a5;
}

static inline uint32_t crc_next(uint32_t crc, uint8_t data)
{
#ifdef ARCH_LITTLE_ENDIAN
	return (crc >> 8) ^ crc_table[(crc & 0xff) ^ data];
#else
	return (crc << 8) ^ crc_table[((crc >> 24) & 0xff) ^ data];
#endif
}

/*
 * Process 4 bytes in one go
 * The data parameter must contain all 4 bytes;
 *   On big-endian machines: first message byte is the most significant byte
 *   On little-endian machines: first message byte is the least significant byte
 */
static inline uint32_t crc_next4(uint32_t crc, uint32_t data)
{
#ifdef ARCH_LITTLE_ENDIAN
	crc ^= data;
	crc = (crc >> 8) ^ crc_table[crc & 0xff];
	crc = (crc >> 8) ^ crc_table[crc & 0xff];
	crc = (crc >> 8) ^ crc_table[crc & 0xff];
	crc = (crc >> 8) ^ crc_table[crc & 0xff];
#else
	crc ^= data;
	crc = (crc << 8) ^ crc_table[(crc >> 24) & 0xff];
	crc = (crc << 8) ^ crc_table[(crc >> 24) & 0xff];
	crc = (crc << 8) ^ crc_table[(crc >> 24) & 0xff];
	crc = (crc << 8) ^ crc_table[(crc >> 24) & 0xff];
#endif
	return crc;
}

static inline uint32_t crc_final(uint32_t crc)
{
#ifdef ARCH_LITTLE_ENDIAN
	crc = (crc >> 16) | ((crc & 0xffff) << 16);
	crc = ((crc >> 8) & 0xff00ff) | ((crc & 0xff00ff) << 8);
#endif
	return (crc ^ 0x42a5a542);
}

#endif
